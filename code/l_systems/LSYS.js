/**
 * @author AdamTavares / http://adamtavares.com
*/
var LSYS = LSYS || { REVISION: '1' }
LSYS.Sys = function( _renderer, _iter, _angle, _start ) {
	
	//------------------------------------------------------------
	//  Provided by the user
	//------------------------------------------------------------
	switch( _renderer ) {		// {string}  The renderer '2D' or '3D'
		case '3D':
			this.renderer = LSYS.ThreeD();
			break;
		case '2D':
		default:
			this.renderer = LSYS.TwoD();  
			break;
	}
	
	this.iter = _iter;      	// {int} The total number of iterations.
	this.angle = _angle;     	// {float} The angle.
	this.start = _start;    	// {string} The starting state
	this.rules = [];    		// {array} An array of strings. The rules of the L-System. 
	
	//------------------------------------------------------------
	//  Generated by the program
	//------------------------------------------------------------
	this.n = 0;         		// {int}  The current iteration.
	this.drawing = this.start;	// {string} The string which becomes a drawing with the help of a renderer
	
	//------------------------------------------------------------
	//  Everything after the 3rd parameter is a rule
	//------------------------------------------------------------
	for ( var i=4; i<arguments.length; i++ ) {
		this.rules[i-4] = arguments[i];
	}
	
	return {
		
		/**
		 *	Run the system the specified # of times i.e. this.iter
		 */
		go: function() {
			while( this.n < this.iter ) {
				this.next();
			}
			console.log( this.drawing );
		},
		
		/**
		 *  Apply the next rule
		 */
		next: function() {
			//------------------------------------------------------------
			//  Apply next rule
			//------------------------------------------------------------
			//------------------------------------------------------------
			//  There's an obvious bug happening here.  I need to apply
			//  rules only if there are applicable rules before any rules
			//  are applied.
			//------------------------------------------------------------
			var i = 0;
			var letters = this.drawing.split('');
			for ( var j in letters ) {
				var letter = letters[j];
				while ( i < this.rules.length ) {
					var rule = this.rules[i];
					var map = rule.split('=');
					letter = letter.replace( map[0], map[1] );
					console.log( letters[j] );
					i++;
				}
			}
			this.drawing = letters.join('');
			
			//------------------------------------------------------------
			//  If last rule is reached loop back to first rule
			//------------------------------------------------------------
			this.n++;
			
		},
		
		draw: function() {
			this.renderer.draw( this.drawing, this.angle );
		},
		
		//------------------------------------------------------------
		//  Expose variables you need
		//------------------------------------------------------------
		n: this.n,
		rules: this.rules,
		iter: this.iter,
		drawing: this.drawing
	}
}



LSYS.Renderer = function() {
	this.RAD = Math.PI/180.0;
	this.ANTICLOCK  = '+';
	this.CLOCKWISE  = '-';
	this.PUSH       = '[';
	this.POP        = ']';
	this.COLOUR     = 'C';
}



//------------------------------------------------------------
//  2D renderer class
//------------------------------------------------------------
LSYS.TwoD = function(){
	return {
		draw: function( _drawing, _angle ) {}
	}
}
LSYS.TwoD.prototype = Object.create( LSYS.Renderer.prototype );



//------------------------------------------------------------
//  3D renderer class
//------------------------------------------------------------
LSYS.ThreeD = function(){
	return {
		draw: function( _drawing, _angle ) {}
	}
}
LSYS.ThreeD.prototype = Object.create( LSYS.Renderer.prototype );

//------------------------------------------------------------
// Stuff to investigate.
//------------------------------------------------------------
// semi-Thue grammar
// Chomsky hierarchy
// L-systems are now commonly known as parametric L systems.
// G = ( V, w, P )